# 변경 보고서 템플릿

아래 템플릿을 기반으로 보고서를 작성한다. 변경 유형에 따라 섹션을 조정한다.

---

```markdown
# {변경 제목}

> **브랜치**: `{branch_name}`
> **기간**: {first_commit_date} ~ {last_commit_date}
> **커밋 수**: {commit_count}개
> **변경 유형**: {feat | refactor | fix | perf | mixed}

## 개요

{1~3문장으로 이번 변경의 핵심 목적과 결과를 서술}

## 커밋 히스토리

| 해시 | 메시지 | 날짜 |
|------|--------|------|
| `abc1234` | feat: 댓글 생성 기능 추가 | 2025-02-04 |
| `def5678` | test: 댓글 생성 테스트 추가 | 2025-02-04 |

## 변경 파일 요약

### 신규 파일

| 파일 | 핵심 내용 |
|------|----------|
| `src/main/java/.../NewClass.java:1` | 설명 |

### 삭제 파일

| 파일 | 사유 |
|------|------|
| `src/main/java/.../OldClass.java` | 삭제 사유 |

### 수정 파일

| 파일 | 핵심 변경 내용 |
|------|---------------|
| `src/main/java/.../Service.java:42` | 변경 내용 |

## 상세 변경 내용

### Phase 1: {제목}

{변경 내용 설명}

**Before** (`{file_path}:{line}`)

```java
// 변경 전 코드 (한 줄 코드는 줄바꿈 없이)
```

**After** (`{file_path}:{line}`)

```java
// 변경 후 코드
```

### Phase 2: {제목}

{변경 내용 설명}

## 아키텍처 다이어그램

### {기능명} 흐름

```mermaid
{변경 유형에 맞는 다이어그램}
```

{다이어그램에 대한 1~2줄 설명}

## 영향 범위 분석

### 직접 영향

| 모듈 | 영향받는 파일 | 영향 내용 |
|------|-------------|----------|
| notification | `NotificationEventHandler.java:55` | CommentCreateEvent 구독 |

### 간접 영향

- {이 변경으로 인해 향후 영향받을 수 있는 부분}

## 테스트 현황

### 신규 테스트

| 테스트 파일 | 검증 내용 |
|------------|----------|
| `src/test/java/.../Test.java:1` | 검증 내용 |

### 수정된 테스트

| 테스트 파일 | 변경 내용 |
|------------|----------|
| `src/test/java/.../Test.java:1` | 변경 내용 |

### 테스트 커버리지

- 변경된 프로덕션 코드 중 테스트가 존재하는 파일: {n}/{total}
- 테스트 미작성 파일:
  - `{file_path}` - {사유}

## 잠재적 이슈

- **{이슈 1}**: {설명} (`{file_path}:{line}`)
- **{이슈 2}**: {설명} (`{file_path}:{line}`)

## DB 마이그레이션

{Flyway 마이그레이션 파일이 포함된 경우에만 이 섹션 추가, 없으면 생략}

| 파일 | 내용 |
|------|------|
| `V{version}__{description}.sql` | {변경 내용} |
```

---

## 섹션별 작성 가이드

### 개요
- 기술적 세부사항보다 "무엇을 왜 했는지"에 집중
- 비개발자도 이해할 수 있는 수준의 요약

### 변경 파일 요약
- 신규/삭제/수정 세 카테고리로 분리하여 한눈에 파악 가능하게 구성
- 모든 변경 파일을 `file_path:line_number` 형식으로 링크
- line_number는 해당 파일에서 가장 핵심적인 변경이 있는 라인
- 삭제 파일은 line_number 생략

### 상세 변경 내용
- 커밋을 논리적 Phase로 그룹핑 (시간순)
- 단순한 import 추가, 포맷팅 변경 등은 생략
- before/after는 핵심 변경 지점만 선별 (전체 파일 복사 금지)
- 코드 블록은 관련 메서드/클래스만 발췌
- **Java 코드 포맷팅 주의**: 린터가 코드 블록 내부를 자동 포맷할 수 있으므로, `if`, 메서드 체이닝 등은 한 줄로 작성

### 아키텍처 다이어그램
- 변경 유형에 따라 자동 선택:
  - `feat:` → sequenceDiagram (Controller→Service→Repository 호출 흐름)
  - `refactor:` → flowchart LR (Before/After 구조 비교, subgraph 활용)
  - `fix:` → flowchart TD (문제→원인→수정→결과)
  - `perf:` → flowchart (최적화 포인트)
  - `mixed` → 가장 비중이 큰 유형 기준, 필요시 다이어그램 복수 포함
- participant 이름은 실제 클래스명 사용
- flowchart에서 한국어 특수문자가 포함된 레이블은 큰따옴표로 감싸기

### 영향 범위 분석
- Grep으로 변경된 클래스/메서드를 참조하는 다른 파일 탐색
- 이벤트 기반 연결 (EventHandler ↔ Event) 포함
- 직접 영향 (코드 레벨)과 간접 영향 (기능/인프라 레벨) 구분
- 클라이언트 영향, CI/CD 영향 등 외부 영향도 기술

### 테스트 현황
- 신규 테스트와 수정된 테스트를 별도 테이블로 분리
- 변경된 프로덕션 코드에 대응하는 테스트 파일 매핑
- 테스트 미작성 파일은 명시적으로 표기
- 삭제된 테스트도 기록 (사유 포함)

### 잠재적 이슈
- 동시성 문제, 성능 영향, 하위 호환성 등
- 추측이 아닌 코드 근거 기반으로 작성
- 해당 코드 위치를 `file_path:line` 형식으로 링크

### DB 마이그레이션
- `db/migration/` 하위 파일이 변경에 포함된 경우에만 섹션 추가
- 없으면 섹션 자체를 생략
