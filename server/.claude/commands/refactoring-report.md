# 리팩토링 계획 및 보고서 생성

리팩토링 **전**에 대상 코드를 분석하고, 상세 계획을 수립하며, 13개 섹션으로 구성된 보고서를 생성합니다.

## 사용법

```
/refactoring-report [리팩토링 대상]
```

**예시**:
- `/refactoring-report AdminService의 N+1 쿼리 최적화`
- `/refactoring-report MomentService 중복 코드 제거`
- `/refactoring-report UserRepository 쿼리 성능 개선`

## Instructions

다음 리팩토링 대상에 대해 분석, 계획 수립, 보고서 작성을 수행합니다: **$ARGUMENTS**

---

## Phase 1: 대상 코드 분석 (Pre-Refactoring Analysis)

### 1.1 코드 식별 및 문제점 파악
- 리팩토링이 필요한 코드와 그 이유 식별
- 관련 파일 및 클래스 탐색
- 현재 코드의 문제점 및 개선 필요성 파악

### 1.2 현재 기능/동작 이해
- 현재 코드의 동작 방식 완전히 이해
- 비즈니스 로직 흐름 파악
- 입출력 데이터 구조 분석

### 1.3 기존 테스트 및 문서 검토
- 기존 테스트 커버리지 확인
- 관련 문서 검토
- 동작 보장을 위한 추가 테스트 필요 여부 판단

### 1.4 의존성 및 사용 지점 식별
- 모든 의존성 파악
- 해당 코드를 사용하는 지점 식별
- 변경 시 영향 범위 분석

---

## Phase 2: 상세 리팩토링 계획 수립 (Refactoring Strategy)

### 2.1 리팩토링 목표 정의
- 성능 개선
- 가독성 향상
- 유지보수성 개선
- 테스트 용이성 향상

### 2.2 리팩토링 기법 선택
적절한 기법 선택:
- Extract Method/Function
- Extract Class/Component
- Rename Variable/Method
- Move Method/Field
- Replace Conditional with Polymorphism
- Eliminate Dead Code
- Apply Design Pattern

### 2.3 단계별 실행 계획
- 작은 단위로 분할된 리팩토링 단계
- 각 단계별 테스트 계획
- 커밋 전략

### 2.4 대안 비교 및 선택 근거
- 가능한 대안 목록
- 각 대안의 장단점
- 최종 선택 및 그 이유

---

## Phase 3: 보고서 생성

`.claude/docs/refactor/report/` 경로에 다음 형식의 마크다운 파일을 생성합니다:
- 파일명: `YYYYMMDD-[리팩토링-대상]-리팩토링-계획서.md`
- 예시: `20260118-AdminService-N+1-최적화-리팩토링-계획서.md`

---

## 보고서 템플릿 (13개 섹션)

```markdown
# [리팩토링 대상] 리팩토링 계획서

> 작성일: YYYY-MM-DD
> 작성자: Claude
> 리팩토링 유형: [N+1 최적화 | 중복 제거 | 패턴 적용 | 성능 개선 | 구조 개선 | 기타]
> 상태: 계획 수립 완료 (리팩토링 전)

---

## 1. 개요

### 1.1 배경
- 리팩토링을 수행하게 된 배경과 맥락
- 비즈니스 요구사항 또는 기술적 필요성

### 1.2 문제 정의
- 해결하고자 하는 핵심 문제
- 문제의 영향 범위와 심각도

### 1.3 리팩토링 유형
- [ ] N+1 쿼리 최적화
- [ ] 중복 코드 제거
- [ ] 디자인 패턴 적용
- [ ] 성능 최적화
- [ ] 코드 구조 개선
- [ ] 기타: _________________

---

## 2. 문제 분석

### 2.1 현재 코드 (Before)

```java
// 문제가 있는 현재 코드
```

### 2.2 현재 실행 흐름

```
[호출 흐름도 또는 시퀀스]
1.
2.
3.
```

### 2.3 문제점 상세

| 문제 | 원인 | 영향 |
|------|------|------|
| | | |

---

## 3. 해결 방안 (예상)

### 3.1 예상 코드 (After)

```java
// 리팩토링 후 예상되는 코드
```

### 3.2 예상 실행 흐름

```
[개선된 호출 흐름도]
1.
2.
3.
```

### 3.3 핵심 변경 계획

| 항목 | Before | After (예상) |
|------|--------|--------------|
| | | |

---

## 4. 선택 이유

### 4.1 대안 비교

| 방안 | 장점 | 단점 | 채택 여부 |
|------|------|------|-----------|
| 방안 A | | | |
| 방안 B | | | |
| **선택된 방안** | | | ✅ |

### 4.2 핵심 선택 이유
1.
2.
3.

---

## 5. 장점과 단점

### 5.1 예상 장점
-

### 5.2 예상 단점 (트레이드오프)
-

### 5.3 단점 완화 방안
-

---

## 6. 기술적 지식

### 6.1 관련 개념
-

### 6.2 적용할 패턴
-

### 6.3 예상 성능 특성
- 시간 복잡도:
- 공간 복잡도:

### 6.4 참고 자료
-

---

## 7. 예상 성능 비교

### 7.1 예상 정량적 비교

| 메트릭 | Before | After (예상) | 예상 개선율 |
|--------|--------|--------------|-------------|
| 쿼리 수 | | | |
| 응답 시간 | | | |
| 메모리 사용량 | | | |

### 7.2 성능 검증 계획
- 부하 테스트 방법:
- 측정 지표:

---

## 8. 적용 위치

### 8.1 변경 예정 파일 목록

| 파일 경로 | 변경 유형 | 설명 |
|-----------|-----------|------|
| | 수정/추가/삭제 | |

### 8.2 영향 범위
- 직접 영향:
- 간접 영향:

### 8.3 의존성 변경
-

---

## 9. 테스트 전략

### 9.1 기존 테스트 현황

| 테스트 파일 | 커버리지 | 상태 |
|-------------|----------|------|
| | | ✅ 통과 / ❌ 실패 |

### 9.2 추가/수정 예정 테스트

| 테스트 케이스 | 목적 | 유형 |
|---------------|------|------|
| | | 단위/통합/E2E |

### 9.3 테스트 시나리오 예시

```java
// 핵심 테스트 코드 예시
@Test
void 테스트_케이스명() {
    // given

    // when

    // then
}
```

### 9.4 테스트 실행 명령어
```bash
./gradlew test --tests "패키지명.*"
```

---

## 10. 롤백 계획

### 10.1 롤백 트리거 조건
- [ ] 성능 저하 (응답 시간 X% 이상 증가)
- [ ] 에러율 증가 (X% 이상)
- [ ] 기능 장애 발생
- [ ] 기타: _________________

### 10.2 롤백 절차

```bash
# 1. 이전 버전으로 롤백
git revert [commit-hash]

# 2. 배포
[배포 명령어]

# 3. 확인
[확인 절차]
```

### 10.3 데이터 복구 (해당 시)
- DB 마이그레이션 롤백:
- 데이터 정합성 확인:

---

## 11. 성능 모니터링 계획

### 11.1 모니터링 메트릭

| 메트릭 | 정상 범위 | 알림 임계값 |
|--------|-----------|-------------|
| 응답 시간 | | |
| 에러율 | | |
| DB 쿼리 수 | | |

### 11.2 모니터링 도구
- [ ] Application Metrics (Actuator)
- [ ] DB Query Log
- [ ] APM (해당 시)

### 11.3 알림 설정
-

---

## 12. 리뷰 체크리스트

### 12.1 리팩토링 전 체크리스트
- [ ] 기존 코드 이해 완료
- [ ] 영향 범위 파악
- [ ] 기존 테스트 존재 여부 확인
- [ ] Green 상태 확인 (모든 테스트 통과)
- [ ] 롤백 계획 수립

### 12.2 리팩토링 중 체크리스트
- [ ] TDD 사이클 준수 (Red → Green → Refactor)
- [ ] 작은 단위 커밋
- [ ] 구조적/행동적 변경 분리
- [ ] 각 변경 후 테스트 실행

### 12.3 리팩토링 후 체크리스트
- [ ] 기존 동작이 유지되는가?
- [ ] 테스트가 충분한가?
- [ ] 성능이 개선되었는가?
- [ ] 코드 가독성이 향상되었는가?
- [ ] SOLID 원칙을 준수하는가?
- [ ] 프로젝트 컨벤션을 따르는가?

### 12.4 배포 전 체크리스트
- [ ] 전체 테스트 통과 (`./gradlew test`)
- [ ] 빌드 성공 (`./gradlew build`)
- [ ] 로컬 환경 테스트 완료
- [ ] 롤백 계획 확인

---

## 13. 결론

### 13.1 요약
-

### 13.2 예상 효과
-

### 13.3 실행 우선순위
- [ ] 높음 (즉시 실행)
- [ ] 중간 (이번 스프린트)
- [ ] 낮음 (백로그)

### 13.4 향후 고려사항
-

### 13.5 관련 이슈/PR
- Issue: #
- PR: # (리팩토링 완료 후 추가)

### 13.6 참고 자료
-
```

---

## 출력

1. Phase 1~2를 수행하여 대상 코드를 분석하고 상세 계획을 수립합니다.
2. 위 템플릿을 기반으로 **분석 결과와 계획을 채운 보고서**를 생성합니다.
3. 파일 위치: `.claude/docs/refactor/report/YYYYMMDD-[대상]-리팩토링-계획서.md`
4. 보고서 생성 후 파일 경로를 안내합니다.

**참고**:
- 이 보고서는 **리팩토링 전**에 작성되는 계획서입니다.
- "After" 섹션은 모두 "예상" 결과로 작성됩니다.
- 리팩토링 완료 후 실제 결과로 업데이트할 수 있습니다.
- 리팩토링 대상에 따라 일부 섹션은 "해당 없음"으로 표시될 수 있습니다.
- 실제 리팩토링 실행은 `/code_refactor` 명령을 사용하세요.
